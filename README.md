# 关于Namespace

&emsp;&emsp;这是一个用于WEB前端代码组织以及动态加载js的框架，加载方式为Ajax同步加载（怕阻塞页面？js都加不进来还搞什么，赶紧关页面吧，投诉运营商），所以采用同步的方式加载。

&emsp;&emsp;异步加载不可避免会有回调产生，还会有层层嵌套，看起来很不爽，果断弃之。如果只在模块中写类的代码实现，则只会在文件加载后设定模块间的引用关系（这是正确的方式）， 不要在模块文件中放入加载后即运行的代码，这是同步加载方案，加载的时候执行代码，卡住找谁？（这是错误的方式），而且加进来就会自己跑的代码还要入口函数干什么?

&emsp;&emsp;入口模块的指定是通过Namespace.js所在的script标签上设置start='Launch.js'属性确定（Launch名字随意），Namespace首先会自动加载Launch.js入口模块，并在之后所有引用的模块Import完成后，自动实例化入口模块Launch的实例，所以一切都开始于Lanuch的构造函数。

&emsp;&emsp;这是多年后的重生版，完成于2019.3.7张家港（其实这代码2009年就诞生了，那会哪有那么多模块加载的框架- -!）， 那些年写JS还是很艰麻烦的，会有很多蛋疼的问题，不像现在有//# sourceURL能定位匿名代码，而且IE上调试起来也麻烦的一笔，那会项目简单用起来也没那么复杂，所以之前的Namespace也没出现什么严重的Bug（也可能是没发现），当然，之前的版本也就只有我自己再用，后来才知道那会跟我一起做项目的同时也用在自己的项目上了，窃喜。

&emsp;&emsp;再后来用起来就遇到了各种问题，比如：模块没有缓存造成重复加载，模块间的循环引用（先有鸡还是先有蛋？），另外模块的引用路径怎么设定规则，还有模块载入完成后的赋值过程也很蛋疼，这几天重写了一遍，把之前遇到的问题都搞定了，主要还是采用在运行时注入代码的方式先拿到引用，再导入之后的模块，一直都不想用往源代码注入的方式，感觉很不优雅，虽然不优雅，不过能解决鸡和蛋的问题，大吉大利。

&emsp;&emsp;整个代码反正也没多长我就不搞Namespace.min.js了（主要是怕错 囧rz..）  

---
## v2.0.1



## v2.0.0



**使用方法**  
只提供了一个方法就是，从'Path/ClassX.js'以同步方式加载文件，并返回ClassX的引用  
var ClassX = Namespace.Import('Path.ClassX')   

1. Chrome测试ok
2. Firfox测试ok
3. Edge应该也没问题
4. 遨游测试ok
5. IE帕斯，不知道是不是console写的有问题，有空试试看
6. 其他浏览器没装，不知道怎么样
---
## v1.x.x
这是很多年前的版本，只能躺在我硬盘里做纪念了
